# ü§ñ bot_handlers.py - Manejadores del Bot v2.6 - FIXED - NO FREEZING
import logging
import time
from flask import request
from config import *
from database import get_initiatives, search_initiatives, create_initiative, calculate_score_fast
from analytics import calculate_statistics_fast, format_statistics_text_fast, analyze_initiatives_with_llm_fast
from utils import send_telegram_message

logger = logging.getLogger(__name__)

# Variables globales para estados de usuario
user_states = {}

def setup_telegram_routes(app):
    """Configurar rutas del bot de Telegram - FIXED VERSION"""
    
    @app.route('/telegram-webhook', methods=['POST'])
    def telegram_webhook():
        """Webhook optimizado con timeout protection"""
        try:
            update_data = request.get_json()
            
            if not update_data or 'message' not in update_data:
                return "OK", 200
            
            message = update_data['message']
            chat_id = message['chat']['id']
            user_id = message['from']['id']
            
            if 'text' not in message:
                return "OK", 200
            
            text = message['text'].strip().lower()
            
            # Timeout wrapper para evitar colgado
            start_time = time.time()
            
            try:
                # Router optimizado - CON TIMEOUT PROTECTION
                if text in ['/start', 'start', 'inicio', 'hola']:
                    handle_start_command(chat_id)
                elif text in ['/help', 'help', 'ayuda']:
                    handle_help_command(chat_id)
                elif text in ['/iniciativas', 'iniciativas', 'lista']:
                    handle_list_initiatives_safe(chat_id)  # FIXED VERSION
                elif text in ['/crear', 'crear', 'nueva']:
                    handle_create_command(chat_id, user_id)
                elif text in ['/analizar', 'analizar', 'an√°lisis']:
                    handle_analyze_command_safe(chat_id)  # FIXED VERSION
                elif text.startswith(('buscar ', '/buscar ')):
                    query = text.split(' ', 1)[1] if ' ' in text else ""
                    if query:
                        handle_search_command_fast(chat_id, query)
                    else:
                        send_telegram_message(chat_id, "üîç **¬øQu√© quieres buscar?**\n\nEjemplos:\n‚Ä¢ buscar Product\n‚Ä¢ buscar API")
                
                # ESTADOS REALES DE LA DB
                elif text in ['/pending', 'pending', 'pendiente']:
                    handle_filter_by_status(chat_id, 'pending')
                elif text in ['/reviewed', 'reviewed', 'revisadas']:
                    handle_filter_by_status(chat_id, 'reviewed')
                elif text in ['/prioritized', 'prioritized', 'priorizadas']:
                    handle_filter_by_status(chat_id, 'prioritized')
                elif text in ['/backlog', 'backlog']:
                    handle_filter_by_status(chat_id, 'backlog')
                elif text in ['/sprint', 'sprint', 'desarrollo', 'dev']:
                    handle_filter_by_status(chat_id, 'sprint')
                elif text in ['/production', 'production', 'produccion', 'prod']:
                    handle_filter_by_status(chat_id, 'production')
                elif text in ['/monitoring', 'monitoring', 'monitoreo']:
                    handle_filter_by_status(chat_id, 'monitoring')
                elif text in ['/discarded', 'discarded', 'descartadas']:
                    handle_filter_by_status(chat_id, 'discarded')
                elif text in ['/estados', 'estados', 'status', 'comandos']:
                    handle_status_info(chat_id)
                elif text in ['/growth', 'growth', 'crecimiento']:  # NUEVO: Comando espec√≠fico Growth
                    handle_growth_analysis(chat_id)
                else:
                    if user_id in user_states:
                        handle_text_message(chat_id, user_id, message['text'])
                    else:
                        handle_natural_message_fast(chat_id, text)
                
                # Check for timeout
                elapsed_time = time.time() - start_time
                if elapsed_time > 25:  # 25 seconds timeout
                    logger.warning(f"‚ö†Ô∏è Command took too long: {elapsed_time:.1f}s")
                    send_telegram_message(chat_id, "‚ö†Ô∏è Comando tard√≥ m√°s de lo esperado. Reintenta.")
                
            except Exception as e:
                logger.error(f"‚ùå Command processing error: {e}")
                send_telegram_message(chat_id, f"‚ùå Error procesando comando: {str(e)}")
            
            return "OK", 200
            
        except Exception as e:
            logger.error(f"‚ùå Webhook error: {e}")
            return "Handled with error", 200

def handle_list_initiatives_safe(chat_id):
    """Listar iniciativas con protecci√≥n contra colgado - FIXED VERSION"""
    logger.info(f"üì± List initiatives SAFE from chat {chat_id}")
    
    try:
        # Mensaje inmediato para mostrar que est√° funcionando
        send_telegram_message(chat_id, "‚ö° **Cargando iniciativas...** (esto puede tardar 10-15s)")
        
        # Timeout protection
        start_time = time.time()
        
        # Intentar obtener datos con timeout
        data = None
        max_attempts = 3
        
        for attempt in range(max_attempts):
            try:
                logger.info(f"üîÑ Attempt {attempt + 1}/{max_attempts} to fetch initiatives")
                data = get_initiatives()
                
                if data and data.get("success"):
                    break
                else:
                    logger.warning(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {data.get('error') if data else 'No data'}")
                    if attempt < max_attempts - 1:
                        time.sleep(2)  # Wait 2 seconds before retry
                        
            except Exception as e:
                logger.error(f"‚ùå Attempt {attempt + 1} exception: {e}")
                if attempt < max_attempts - 1:
                    time.sleep(2)
                else:
                    send_telegram_message(chat_id, f"‚ùå Error despu√©s de {max_attempts} intentos: {str(e)}")
                    return
        
        # Check timeout
        elapsed_time = time.time() - start_time
        if elapsed_time > 20:  # 20 second timeout
            send_telegram_message(chat_id, "‚ö†Ô∏è **Timeout** - El comando tard√≥ demasiado. Reintenta en unos momentos.")
            return
        
        if not data or not data.get("success"):
            error_msg = data.get('error', 'Error desconocido') if data else 'No se obtuvieron datos'
            send_telegram_message(chat_id, f"‚ùå Error: {error_msg}")
            return
        
        initiatives = data.get("data", [])
        
        if not initiatives:
            send_telegram_message(chat_id, "üî≠ **No hay iniciativas disponibles.**\n\nüí° Usa el comando `crear` para agregar nuevas iniciativas.")
            return
        
        logger.info(f"‚úÖ Successfully fetched {len(initiatives)} initiatives in {elapsed_time:.1f}s")
        
        # Procesar estad√≠sticas de forma segura
        try:
            send_telegram_message(chat_id, "üìä **Generando estad√≠sticas...**")
            stats = calculate_statistics_fast(initiatives)
            stats_text = format_statistics_text_fast(stats)
            
            # Enviar estad√≠sticas en chunks si es muy largo
            if len(stats_text) > MAX_MESSAGE_LENGTH:
                chunks = [stats_text[i:i+MAX_MESSAGE_LENGTH] for i in range(0, len(stats_text), MAX_MESSAGE_LENGTH)]
                for i, chunk in enumerate(chunks):
                    if i == 0:
                        send_telegram_message(chat_id, chunk, parse_mode='Markdown')
                    else:
                        send_telegram_message(chat_id, f"**Continuaci√≥n {i+1}:**\n\n{chunk}", parse_mode='Markdown')
                    time.sleep(1)  # Delay between chunks
            else:
                send_telegram_message(chat_id, stats_text, parse_mode='Markdown')
                
        except Exception as e:
            logger.error(f"‚ùå Error generating stats: {e}")
            send_telegram_message(chat_id, f"‚ùå Error generando estad√≠sticas: {str(e)}")
        
        # Lista r√°pida - solo top 10 para evitar saturaci√≥n
        try:
            send_telegram_message(chat_id, "üìã **Generando lista top...**")
            
            # Usar las iniciativas ya ordenadas de stats si est√°n disponibles
            sorted_initiatives = stats.get('sorted_initiatives', initiatives) if 'stats' in locals() else initiatives
            
            text = f"üìã **TOP {min(MAX_RESULTS_LIST, len(sorted_initiatives))} INICIATIVAS POR SCORE RICE:**\n\n"
            
            for i, init in enumerate(sorted_initiatives[:MAX_RESULTS_LIST], 1):
                try:
                    formatted = format_initiative_summary_safe(init, i)
                    text += f"{formatted}\n\n"
                except Exception as e:
                    logger.warning(f"Error formatting initiative {i}: {e}")
                    text += f"{i}. ‚ùå **Error formateando iniciativa**\n\n"
            
            if len(sorted_initiatives) > MAX_RESULTS_LIST:
                text += f"üìå **{len(sorted_initiatives) - MAX_RESULTS_LIST} iniciativas m√°s...**\nUsa `buscar` para encontrar espec√≠ficas."
            
            # Info de cache
            cache_info = " (Cache)" if data.get("cached") else " (Fresh)"
            text += f"\nüí° **Datos actualizados{cache_info}** - Tiempo: {elapsed_time:.1f}s"
            
            # Enviar lista en chunks si es necesario
            if len(text) > MAX_MESSAGE_LENGTH:
                chunks = [text[i:i+MAX_MESSAGE_LENGTH] for i in range(0, len(text), MAX_MESSAGE_LENGTH)]
                for chunk in chunks:
                    send_telegram_message(chat_id, chunk, parse_mode='Markdown')
                    time.sleep(1)
            else:
                send_telegram_message(chat_id, text, parse_mode='Markdown')
                
        except Exception as e:
            logger.error(f"‚ùå Error generating list: {e}")
            send_telegram_message(chat_id, f"‚ùå Error generando lista: {str(e)}")
        
        # Comandos de seguimiento
        try:
            follow_up = """üí° **Comandos √∫tiles:**
‚Ä¢ `analizar` - An√°lisis estrat√©gico Growth
‚Ä¢ `growth` - An√°lisis espec√≠fico de crecimiento
‚Ä¢ `buscar <t√©rmino>` - Buscar iniciativas
‚Ä¢ `sprint` - Ver iniciativas en desarrollo"""
            send_telegram_message(chat_id, follow_up, parse_mode='Markdown')
        except:
            pass  # No critical if this fails
            
    except Exception as e:
        logger.error(f"‚ùå Fatal error in handle_list_initiatives_safe: {e}")
        send_telegram_message(chat_id, f"‚ùå Error cr√≠tico: {str(e)}\n\nüí° Intenta nuevamente en unos momentos.")

def handle_analyze_command_safe(chat_id):
    """An√°lisis con protecci√≥n contra colgado y enfoque Growth - FIXED VERSION"""
    logger.info(f"üì± Analyze SAFE with Growth focus from chat {chat_id}")
    
    try:
        send_telegram_message(chat_id, "ü§ñ **Iniciando an√°lisis estrat√©gico...** ‚ö°")
        
        start_time = time.time()
        
        # Obtener datos con timeout protection
        data = None
        max_attempts = 2  # Menos intentos para an√°lisis
        
        for attempt in range(max_attempts):
            try:
                logger.info(f"üîÑ Analysis attempt {attempt + 1}/{max_attempts}")
                data = get_initiatives()
                
                if data and data.get("success"):
                    break
                else:
                    logger.warning(f"‚ö†Ô∏è Analysis attempt {attempt + 1} failed")
                    if attempt < max_attempts - 1:
                        time.sleep(3)
                        
            except Exception as e:
                logger.error(f"‚ùå Analysis attempt {attempt + 1} exception: {e}")
                if attempt < max_attempts - 1:
                    time.sleep(3)
        
        if not data or not data.get("success"):
            error_msg = data.get('error', 'Error desconocido') if data else 'No se obtuvieron datos'
            send_telegram_message(chat_id, f"‚ùå Error obteniendo datos para an√°lisis: {error_msg}")
            return
        
        initiatives = data.get("data", [])
        
        if not initiatives:
            send_telegram_message(chat_id, "üî≠ **No hay iniciativas para analizar.**")
            return
        
        # Estad√≠sticas r√°pidas primero
        try:
            send_telegram_message(chat_id, "üìä **Calculando m√©tricas...**")
            stats = calculate_statistics_fast(initiatives)
            stats_text = format_statistics_text_fast(stats)
            
            cache_info = " (Cache)" if data.get("cached") else " (Fresh)"
            stats_text += f"\n‚ö° **Datos{cache_info}**"
            
            # Enviar estad√≠sticas
            if len(stats_text) > MAX_MESSAGE_LENGTH:
                chunks = [stats_text[i:i+MAX_MESSAGE_LENGTH] for i in range(0, len(stats_text), MAX_MESSAGE_LENGTH)]
                for chunk in chunks:
                    send_telegram_message(chat_id, chunk, parse_mode='Markdown')
                    time.sleep(1)
            else:
                send_telegram_message(chat_id, stats_text, parse_mode='Markdown')
                
            logger.info(f"‚úÖ Statistics sent successfully")
            
        except Exception as e:
            logger.error(f"‚ùå Statistics error: {e}")
            send_telegram_message(chat_id, f"‚ùå Error en estad√≠sticas: {str(e)}")
            return
        
        # Check timeout before AI analysis
        elapsed_time = time.time() - start_time
        if elapsed_time > 15:
            send_telegram_message(chat_id, "‚ö†Ô∏è **Proceso tardando m√°s de lo esperado** - Continuando con an√°lisis IA...")
        
        # An√°lisis AI optimizado con mejor error handling
        if not GROQ_API_KEY:
            send_telegram_message(chat_id, "‚ö†Ô∏è **An√°lisis AI no disponible**\n\nEl sistema no tiene configurada la API key de Groq. Las estad√≠sticas est√°n disponibles arriba.")
            return
        
        try:
            send_telegram_message(chat_id, "üß† **Generando an√°lisis estrat√©gico Growth...** (10-20s)")
            
            logger.info(f"ü§ñ Starting Growth-focused AI analysis with {len(initiatives)} initiatives")
            
            # Timeout para el an√°lisis IA
            ai_start = time.time()
            analysis = analyze_initiatives_with_llm_fast(initiatives)
            ai_elapsed = time.time() - ai_start
            
            if not analysis or analysis.strip() == "":
                send_telegram_message(chat_id, "‚ùå **An√°lisis vac√≠o**\n\nEl AI no gener√≥ respuesta. Las estad√≠sticas est√°n disponibles arriba.")
                return
            
            total_elapsed = time.time() - start_time
            
            analysis_text = f"ü§ñ **AN√ÅLISIS ESTRAT√âGICO GROWTH - SALUDIA** üöÄ\n\n{analysis}"
            analysis_text += f"\n\n‚è±Ô∏è **Tiempo:** Datos: {elapsed_time:.1f}s | IA: {ai_elapsed:.1f}s | Total: {total_elapsed:.1f}s"
            
            # Enviar an√°lisis (dividir si es muy largo)
            if len(analysis_text) > MAX_MESSAGE_LENGTH:
                chunks = [analysis_text[i:i+MAX_MESSAGE_LENGTH] for i in range(0, len(analysis_text), MAX_MESSAGE_LENGTH)]
                for i, chunk in enumerate(chunks):
                    if i == 0:
                        send_telegram_message(chat_id, chunk, parse_mode='Markdown')
                    else:
                        send_telegram_message(chat_id, f"**Continuaci√≥n {i+1}:**\n\n{chunk}", parse_mode='Markdown')
                    time.sleep(1)
            else:
                send_telegram_message(chat_id, analysis_text, parse_mode='Markdown')
            
            logger.info(f"‚úÖ Growth analysis completed and sent in {total_elapsed:.1f}s")
            
        except Exception as e:
            logger.error(f"‚ùå AI Analysis error: {e}")
            error_msg = f"‚ùå **Error en an√°lisis AI:**\n\n{str(e)}\n\nüí° Las estad√≠sticas b√°sicas est√°n disponibles arriba."
            send_telegram_message(chat_id, error_msg, parse_mode='Markdown')
    
    except Exception as e:
        logger.error(f"‚ùå Fatal error in analyze command: {e}")
        send_telegram_message(chat_id, f"‚ùå Error cr√≠tico en an√°lisis: {str(e)}")

def handle_growth_analysis(chat_id):
    """Nuevo comando espec√≠fico para an√°lisis de Growth"""
    logger.info(f"üì± Growth-specific analysis from chat {chat_id}")
    
    try:
        send_telegram_message(chat_id, "üöÄ **AN√ÅLISIS ESPEC√çFICO DE GROWTH** üöÄ")
        
        data = get_initiatives()
        
        if not data or not data.get("success"):
            send_telegram_message(chat_id, "‚ùå Error obteniendo datos para an√°lisis Growth.")
            return
        
        initiatives = data.get("data", [])
        
        if not initiatives:
            send_telegram_message(chat_id, "üî≠ No hay iniciativas para analizar.")
            return
        
        # Filtrar iniciativas de Growth
        growth_initiatives = [init for init in initiatives if 
                            str(init.get('team', '')).strip().lower() == 'growth']
        
        total_initiatives = len(initiatives)
        growth_count = len(growth_initiatives)
        
        # Calcular m√©tricas espec√≠ficas de Growth
        if growth_initiatives:
            growth_scores = [calculate_score_fast(init) for init in growth_initiatives]
            avg_growth_score = sum(growth_scores) / len(growth_scores)
            high_priority_growth = len([s for s in growth_scores if s >= 2.0])
            
            # Ordenar por score
            growth_initiatives.sort(key=calculate_score_fast, reverse=True)
            
            analysis = f"""üöÄ **AN√ÅLISIS ESPEC√çFICO GROWTH - SALUDIA**

üìä **M√âTRICAS GROWTH:**
‚Ä¢ Iniciativas Growth: {growth_count} de {total_initiatives} ({(growth_count/total_initiatives)*100:.1f}%)
‚Ä¢ Score promedio Growth: {avg_growth_score:.2f}
‚Ä¢ Alta prioridad (‚â•2.0): {high_priority_growth} iniciativas

üèÜ **TOP INICIATIVAS GROWTH:**
"""
            
            for i, init in enumerate(growth_initiatives[:5], 1):
                score = calculate_score_fast(init)
                priority_emoji = "üî•" if score >= 2.0 else "‚≠ê" if score >= 1.0 else "üìã"
                
                analysis += f"""
{i}. {priority_emoji} **{init.get('initiative_name', 'Sin nombre')}** (Score: {score:.2f})
   üë§ {init.get('owner', 'Sin owner')} | üñ•Ô∏è {init.get('portal', 'Sin portal')}
   üìä KPI: {init.get('main_kpi', 'Sin KPI')}
   üìù {init.get('description', 'Sin descripci√≥n')[:100]}...
"""
            
            analysis += f"""

üí° **RECOMENDACIONES GROWTH:**
"""
            
            if high_priority_growth == 0:
                analysis += "‚Ä¢ ‚ö†Ô∏è No hay iniciativas Growth de alta prioridad (Score ‚â• 2.0)"
            else:
                analysis += f"‚Ä¢ ‚úÖ {high_priority_growth} iniciativas Growth de alta prioridad - Ejecutar inmediatamente"
            
            if avg_growth_score < 1.0:
                analysis += "\n‚Ä¢ ‚ö†Ô∏è Score promedio Growth bajo - Revisar estimaciones RICE"
            else:
                analysis += f"\n‚Ä¢ ‚úÖ Score promedio Growth saludable: {avg_growth_score:.2f}"
            
            if growth_count < 3:
                analysis += "\n‚Ä¢ ‚ö†Ô∏è Pocas iniciativas Growth - Considerar m√°s proyectos de crecimiento"
            
        else:
            analysis = f"""üöÄ **AN√ÅLISIS ESPEC√çFICO GROWTH - SALUDIA**

‚ö†Ô∏è **NO HAY INICIATIVAS DE GROWTH IDENTIFICADAS**

üìä **Estado actual:**
‚Ä¢ Total iniciativas: {total_initiatives}
‚Ä¢ Iniciativas Growth: 0 (0%)

üí° **RECOMENDACIONES CR√çTICAS:**
‚Ä¢ üö® URGENTE: Crear iniciativas espec√≠ficas para el equipo Growth
‚Ä¢ üéØ Enfocar en: Adquisici√≥n de usuarios, Retention, Conversion Rate
‚Ä¢ üìà KPIs sugeridos: GMV, Take Rate, User Acquisition Cost
‚Ä¢ üöÄ Considerar iniciativas de marketing, onboarding, referral programs

üéØ **Pr√≥ximos pasos:**
1. Usar comando `crear` para agregar iniciativas Growth
2. Balancear portfolio con iniciativas de crecimiento
3. Establecer KPIs claros de Growth para Saludia marketplace"""
        
        send_telegram_message(chat_id, analysis, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Growth analysis error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en an√°lisis Growth: {str(e)}")

def format_initiative_summary_safe(initiative, index=None):
    """Formatear iniciativa optimizado y seguro - FIXED VERSION"""
    try:
        # Usar safe_get para evitar errores con None
        name = safe_get_string_local(initiative, 'initiative_name', 'Sin nombre')
        owner = safe_get_string_local(initiative, 'owner', 'Sin owner')
        team = safe_get_string_local(initiative, 'team', 'Sin equipo')
        
        # Calcular score de forma segura
        score = 0.0
        try:
            score = calculate_score_fast(initiative)
        except Exception as e:
            logger.warning(f"Error calculating score: {e}")
            score = 0.0
        
        priority_emoji = "üî•" if score >= 2.0 else "‚≠ê" if score >= 1.0 else "üìã"
        prefix = f"**{index}.** " if index else ""
        
        # Emoji especial para Growth
        team_emoji = "üöÄ" if team.lower() == "growth" else "üë•"
        
        return f"{prefix}{priority_emoji} **{name}** (Score: {score:.2f})\n{team_emoji} {team} | üë§ {owner}"
        
    except Exception as e:
        logger.error(f"Format error: {e}")
        return f"{index}. ‚ùå **Error de formato**" if index else "‚ùå **Error de formato**"

def safe_get_string_local(obj, key, default=''):
    """Helper local para obtener strings de forma segura"""
    try:
        value = obj.get(key, default) if obj else default
        if value is None:
            return default
        return str(value).strip() if str(value).strip() else default
    except:
        return default

def handle_start_command(chat_id):
    """Comando start optimizado"""
    logger.info(f"üì± /start from chat {chat_id}")
    
    text = """üéØ **Bot Saludia v2.6** ‚ö° GESTI√ìN DE INICIATIVAS

ü•º **Saludia Marketplace Farmac√©utico**
Asistente especializado en gesti√≥n de iniciativas con metodolog√≠a RICE, enfocado en **GROWTH** y crecimiento del negocio.

**üìã Comandos principales:**
‚Ä¢ `iniciativas` - Lista ordenada por score RICE
‚Ä¢ `analizar` - An√°lisis AI estrat√©gico completo  
‚Ä¢ `growth` - üöÄ An√°lisis espec√≠fico de crecimiento
‚Ä¢ `buscar <t√©rmino>` - B√∫squeda por equipo/proyecto
‚Ä¢ `crear` - Nueva iniciativa con RICE

**üìä Filtros por Estado:**
‚Ä¢ `pending` - Pendientes de revisi√≥n
‚Ä¢ `sprint` - En desarrollo activo  
‚Ä¢ `production` - Implementadas
‚Ä¢ `monitoring` - En monitoreo

**üöÄ Enfoque Growth:**
‚Ä¢ Maximizar GMV del marketplace
‚Ä¢ Optimizar adquisici√≥n y retenci√≥n
‚Ä¢ Balancear Droguer√≠as ‚Üî Sellers
‚Ä¢ M√©tricas: Conversion Rate, Take Rate, NPS

**‚ö° Nuevo en v2.6:**
‚Ä¢ An√°lisis espec√≠fico Growth
‚Ä¢ Protecci√≥n contra timeouts
‚Ä¢ Error handling mejorado
‚Ä¢ Cache inteligente

üí° **Tip:** Comandos simples, ej: `growth` o `sprint`"""
    
    send_telegram_message(chat_id, text, parse_mode='Markdown')

def handle_help_command(chat_id):
    """Comando help optimizado con enfoque Growth"""
    text = """üìö **Comandos Disponibles** ‚ö° v2.6 - GROWTH FOCUSED

**üöÄ Comandos Growth:**
‚Ä¢ `growth` - An√°lisis espec√≠fico de crecimiento
‚Ä¢ `analizar` - An√°lisis AI estrat√©gico completo

**üìä Comandos B√°sicos:**
‚Ä¢ `iniciativas` - Lista completa por score RICE
‚Ä¢ `buscar <t√©rmino>` - B√∫squeda optimizada
‚Ä¢ `crear` - Nueva iniciativa con validaciones RICE

**üìà Filtros por Estado:**
‚Ä¢ `pending` - Pendientes | `sprint` - En desarrollo  
‚Ä¢ `production` - Implementadas | `monitoring` - En monitoreo

**üîç Ejemplos de B√∫squeda:**
‚Ä¢ `buscar Growth` - Iniciativas de crecimiento
‚Ä¢ `buscar GMV` - Por KPI espec√≠fico
‚Ä¢ `buscar Juan` - Por responsable

**üèÜ Sistema RICE (Reach √ó Impact √ó Confidence / Effort):**
‚Ä¢ üî• Score ‚â• 2.0 - Alta prioridad (ejecutar YA)
‚Ä¢ ‚≠ê Score ‚â• 1.0 - Media prioridad (pr√≥ximos sprints)
‚Ä¢ üìã Score < 1.0 - Baja prioridad (re-evaluar)

**üéØ Flujo de Estados:**
Pending ‚Üí Reviewed ‚Üí Prioritized ‚Üí Backlog ‚Üí Sprint ‚Üí Production ‚Üí Monitoring

**üöÄ Especializaci√≥n Growth:**
‚Ä¢ An√°lisis enfocado en crecimiento del marketplace
‚Ä¢ KPIs: GMV, Take Rate, User Acquisition, Retention
‚Ä¢ Balance Droguer√≠as ‚Üî Sellers/Laboratorios
‚Ä¢ Optimizaci√≥n de conversi√≥n y experiencia

üí° **Tip:** Usa `growth` para an√°lisis espec√≠fico de crecimiento"""
    
    send_telegram_message(chat_id, text, parse_mode='Markdown')

def handle_natural_message_fast(chat_id, text):
    """Manejar mensajes naturales optimizado con sugerencias Growth"""
    text_lower = text.lower()
    
    if any(word in text_lower for word in ['crecimiento', 'growth', 'crecer']):
        send_telegram_message(chat_id, "üöÄ An√°lisis Growth: `growth`")
    elif any(word in text_lower for word in ['iniciativa', 'proyecto', 'lista']):
        send_telegram_message(chat_id, "üéØ Ver iniciativas: `iniciativas`")
    elif any(word in text_lower for word in ['buscar', 'encontrar']):
        send_telegram_message(chat_id, "üîç Buscar: `buscar Growth`")
    elif any(word in text_lower for word in ['crear', 'nueva']):
        send_telegram_message(chat_id, "üÜï Crear: `crear`")
    elif any(word in text_lower for word in ['an√°lisis', 'analizar']):
        send_telegram_message(chat_id, "üìä An√°lisis: `analizar`")
    elif any(word in text_lower for word in ['sprint', 'desarrollo', 'dev']):
        send_telegram_message(chat_id, "üîß En desarrollo: `sprint`")
    elif any(word in text_lower for word in ['producci√≥n', 'production', 'implementado']):
        send_telegram_message(chat_id, "üöÄ Implementadas: `production`")
    else:
        send_telegram_message(chat_id, """üí¨ **Comandos disponibles:**

**üöÄ Growth:** `growth`, `analizar`
**üìã B√°sicos:** `iniciativas`, `buscar`, `crear`  
**üìä Estados:** `pending`, `sprint`, `production`

üí° **Tip:** Escribe `help` para ver todos los comandos.""")

def handle_search_command_fast(chat_id, query):
    """B√∫squeda optimizada con timeout protection"""
    logger.info(f"üì± Search FAST '{query}' from chat {chat_id}")
    
    try:
        start_time = time.time()
        result = search_initiatives(query)
        elapsed = time.time() - start_time
        
        if elapsed > 10:
            logger.warning(f"‚ö†Ô∏è Search took {elapsed:.1f}s")
        
        if not result.get("success"):
            send_telegram_message(chat_id, f"‚ùå Error: {result.get('error')}")
            return
        
        results = result.get("results", [])
        total = result.get("total", 0)
        
        if not results:
            send_telegram_message(chat_id, f"""üîç **Sin resultados:** "{query}"

üí° **Sugerencias:**
‚Ä¢ `buscar Growth` - Por equipo Growth
‚Ä¢ `buscar GMV` - Por KPI
‚Ä¢ `iniciativas` - Ver todas""")
            return
        
        text = f"üîç **RESULTADOS:** {query} ({total} encontrados)\n\n"
        
        for i, init in enumerate(results[:MAX_RESULTS_SEARCH], 1):
            try:
                name = safe_get_string_local(init, 'initiative_name', 'Sin nombre')
                team = safe_get_string_local(init, 'team', 'Sin equipo')
                score = calculate_score_fast(init)
                priority = "üî•" if score >= 2.0 else "‚≠ê" if score >= 1.0 else "üìã"
                team_emoji = "üöÄ" if team.lower() == "growth" else "üë•"
                
                text += f"**{i}.** {priority} **{name}** (Score: {score:.2f})\n"
                text += f"{team_emoji} {team} | üë§ {safe_get_string_local(init, 'owner', 'Sin owner')}\n"
                text += f"üìù {safe_get_string_local(init, 'description', 'Sin descripci√≥n')[:100]}...\n\n"
            except Exception as e:
                logger.warning(f"Error formatting search result {i}: {e}")
                continue
        
        if total > MAX_RESULTS_SEARCH:
            text += f"üìå **{total - MAX_RESULTS_SEARCH} resultados m√°s...** Refina tu b√∫squeda."
        
        text += f"\n‚ö° B√∫squeda completada en {elapsed:.1f}s"
        
        send_telegram_message(chat_id, text, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Search error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en b√∫squeda: {str(e)}")

# ===== FUNCIONES DEL COMANDO "crear" =====

def handle_create_command(chat_id, user_id):
    """Iniciar proceso de creaci√≥n de iniciativa - 8 pasos"""
    logger.info(f"üì± Create command from chat {chat_id}, user {user_id}")
    
    try:
        # Inicializar estado del usuario
        user_states[user_id] = {
            'state': 'creating_initiative',
            'step': 1,
            'data': {}
        }
        
        text = """üÜï **CREAR NUEVA INICIATIVA** üéØ

**Metodolog√≠a RICE:** Reach √ó Impact √ó Confidence / Effort

**üìã Proceso (8 pasos):**
1. Nombre de la iniciativa
2. Descripci√≥n detallada  
3. Responsable (owner)
4. Equipo asignado
5. Portal objetivo
6. KPI principal (opcional)
7. M√©tricas RICE
8. Confirmaci√≥n

**üí° Tips:**
‚Ä¢ S√© espec√≠fico en nombre y descripci√≥n
‚Ä¢ Las m√©tricas RICE determinan la prioridad
‚Ä¢ Puedes cancelar escribiendo "cancelar"

**‚û°Ô∏è PASO 1/8: Nombre de la Iniciativa**
Escribe un nombre claro y descriptivo (m√°ximo 255 caracteres):

*Ejemplo: "Integraci√≥n API de pagos PSE"*"""
        
        send_telegram_message(chat_id, text, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Error starting create command: {e}")
        send_telegram_message(chat_id, f"‚ùå Error iniciando creaci√≥n: {str(e)}")

def handle_text_message(chat_id, user_id, text):
    """Manejar mensajes de texto en estado de creaci√≥n"""
    try:
        if user_id not in user_states:
            # Usuario no est√° en proceso de creaci√≥n
            handle_natural_message_fast(chat_id, text.lower())
            return
        
        user_state = user_states[user_id]
        
        if user_state['state'] != 'creating_initiative':
            # Estado no v√°lido
            del user_states[user_id]
            handle_natural_message_fast(chat_id, text.lower())
            return
        
        # Verificar comando de cancelaci√≥n
        if text.lower().strip() in ['cancelar', 'cancel', 'salir', 'exit']:
            del user_states[user_id]
            send_telegram_message(chat_id, "‚ùå **Creaci√≥n cancelada.**\n\nüí° Usa `crear` para intentar nuevamente.")
            return
        
        step = user_state['step']
        
        # Procesar cada paso
        if step == 1:
            handle_step_1_name(chat_id, user_id, text)
        elif step == 2:
            handle_step_2_description(chat_id, user_id, text)
        elif step == 3:
            handle_step_3_owner(chat_id, user_id, text)
        elif step == 4:
            handle_step_4_team(chat_id, user_id, text)
        elif step == 5:
            handle_step_5_portal(chat_id, user_id, text)
        elif step == 6:
            handle_step_6_kpi(chat_id, user_id, text)
        elif step == 7:
            handle_step_7_rice(chat_id, user_id, text)
        elif step == 8:
            handle_step_8_confirmation(chat_id, user_id, text)
        else:
            # Estado inv√°lido, resetear
            del user_states[user_id]
            send_telegram_message(chat_id, "‚ùå **Estado inv√°lido.** Proceso reiniciado.\n\nUsa `crear` para comenzar nuevamente.")
            
    except Exception as e:
        logger.error(f"‚ùå Error handling text message: {e}")
        if user_id in user_states:
            del user_states[user_id]
        send_telegram_message(chat_id, f"‚ùå Error procesando mensaje: {str(e)}\n\nUsa `crear` para intentar nuevamente.")

def handle_step_1_name(chat_id, user_id, text):
    """PASO 1: Nombre de la iniciativa"""
    try:
        name = text.strip()
        
        # Validaciones
        if not name:
            send_telegram_message(chat_id, "‚ùå **El nombre no puede estar vac√≠o.**\n\nEscribe un nombre claro:")
            return
        
        if len(name) > MAX_INITIATIVE_NAME:
            send_telegram_message(chat_id, f"‚ùå **Nombre muy largo.** M√°ximo {MAX_INITIATIVE_NAME} caracteres.\n\nActual: {len(name)} caracteres. Intenta uno m√°s corto:")
            return
        
        # Guardar y continuar
        user_states[user_id]['data']['initiative_name'] = name
        user_states[user_id]['step'] = 2
        
        text_response = f"""‚úÖ **Nombre guardado:** {name}

**‚û°Ô∏è PASO 2/8: Descripci√≥n Detallada**
Describe qu√© hace esta iniciativa, por qu√© es importante y c√≥mo impacta el negocio (m√°ximo {MAX_DESCRIPTION} caracteres):

*Ejemplo: "Implementar integraci√≥n con PSE y tarjetas de cr√©dito para mejorar la conversi√≥n de checkout en el portal de droguer√≠as. Reducir√° abandono del carrito y aumentar√° GMV."*"""
        
        send_telegram_message(chat_id, text_response, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Step 1 error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en paso 1: {str(e)}")

def handle_step_2_description(chat_id, user_id, text):
    """PASO 2: Descripci√≥n detallada"""
    try:
        description = text.strip()
        
        # Validaciones
        if not description:
            send_telegram_message(chat_id, "‚ùå **La descripci√≥n no puede estar vac√≠a.**\n\nDescribe detalladamente la iniciativa:")
            return
        
        if len(description) > MAX_DESCRIPTION:
            send_telegram_message(chat_id, f"‚ùå **Descripci√≥n muy larga.** M√°ximo {MAX_DESCRIPTION} caracteres.\n\nActual: {len(description)} caracteres. Resume:")
            return
        
        # Guardar y continuar
        user_states[user_id]['data']['description'] = description
        user_states[user_id]['step'] = 3
        
        text_response = f"""‚úÖ **Descripci√≥n guardada:** {description[:100]}{'...' if len(description) > 100 else ''}

**‚û°Ô∏è PASO 3/8: Responsable (Owner)**
¬øQui√©n ser√° el responsable principal de esta iniciativa? Escribe el nombre completo (m√°ximo {MAX_OWNER_NAME} caracteres):

*Ejemplo: "Juan P√©rez"*"""
        
        send_telegram_message(chat_id, text_response, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Step 2 error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en paso 2: {str(e)}")

def handle_step_3_owner(chat_id, user_id, text):
    """PASO 3: Responsable"""
    try:
        owner = text.strip()
        
        # Validaciones
        if not owner:
            send_telegram_message(chat_id, "‚ùå **El responsable no puede estar vac√≠o.**\n\nEscribe el nombre del responsable:")
            return
        
        if len(owner) > MAX_OWNER_NAME:
            send_telegram_message(chat_id, f"‚ùå **Nombre muy largo.** M√°ximo {MAX_OWNER_NAME} caracteres.\n\nActual: {len(owner)} caracteres:")
            return
        
        # Guardar y continuar
        user_states[user_id]['data']['owner'] = owner
        user_states[user_id]['step'] = 4
        
        teams_text = "‚Ä¢ " + "\n‚Ä¢ ".join(VALID_TEAMS)
        
        text_response = f"""‚úÖ **Responsable guardado:** {owner}

**‚û°Ô∏è PASO 4/8: Equipo Asignado**
Selecciona el equipo responsable. Escribe exactamente uno de estos equipos:

{teams_text}

*Escribe solo el nombre del equipo, ejemplo: "Product"*"""
        
        send_telegram_message(chat_id, text_response, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Step 3 error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en paso 3: {str(e)}")

def handle_step_4_team(chat_id, user_id, text):
    """PASO 4: Equipo"""
    try:
        team = text.strip()
        
        # Validar equipo
        if team not in VALID_TEAMS:
            teams_text = "‚Ä¢ " + "\n‚Ä¢ ".join(VALID_TEAMS)
            send_telegram_message(chat_id, f"""‚ùå **Equipo inv√°lido:** {team}

**Equipos v√°lidos:**
{teams_text}

Escribe exactamente uno de los equipos listados:""", parse_mode='Markdown')
            return
        
        # Guardar y continuar
        user_states[user_id]['data']['team'] = team
        user_states[user_id]['step'] = 5
        
        portals_text = "‚Ä¢ " + "\n‚Ä¢ ".join(VALID_PORTALS)
        
        text_response = f"""‚úÖ **Equipo guardado:** {team}

**‚û°Ô∏è PASO 5/8: Portal Objetivo**
¬øEn qu√© portal se implementar√° esta iniciativa? Escribe exactamente uno:

{portals_text}

*Ejemplo: "Droguista" para iniciativas del portal de droguer√≠as*"""
        
        send_telegram_message(chat_id, text_response, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Step 4 error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en paso 4: {str(e)}")

def handle_step_5_portal(chat_id, user_id, text):
    """PASO 5: Portal"""
    try:
        portal = text.strip()
        
        # Validar portal
        if portal not in VALID_PORTALS:
            portals_text = "‚Ä¢ " + "\n‚Ä¢ ".join(VALID_PORTALS)
            send_telegram_message(chat_id, f"""‚ùå **Portal inv√°lido:** {portal}

**Portales v√°lidos:**
{portals_text}

Escribe exactamente uno de los portales listados:""", parse_mode='Markdown')
            return
        
        # Guardar y continuar
        user_states[user_id]['data']['portal'] = portal
        user_states[user_id]['step'] = 6
        
        text_response = f"""‚úÖ **Portal guardado:** {portal}

**‚û°Ô∏è PASO 6/8: KPI Principal (Opcional)**
¬øCu√°l es el KPI principal que esta iniciativa mejorar√°? 

Escribe el KPI o "ninguno" si no aplica (m√°ximo {MAX_KPI_LENGTH} caracteres):

*Ejemplos: "Conversion Rate", "GMV", "User Retention", "ninguno"*"""
        
        send_telegram_message(chat_id, text_response, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Step 5 error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en paso 5: {str(e)}")

def handle_step_6_kpi(chat_id, user_id, text):
    """PASO 6: KPI Principal"""
    try:
        kpi_input = text.strip()
        
        # Validar longitud
        if len(kpi_input) > MAX_KPI_LENGTH:
            send_telegram_message(chat_id, f"‚ùå **KPI muy largo.** M√°ximo {MAX_KPI_LENGTH} caracteres.\n\nActual: {len(kpi_input)} caracteres:")
            return
        
        # Procesar KPI
        if kpi_input.lower() in ['ninguno', 'none', 'na', 'n/a', '']:
            kpi = None
        else:
            kpi = kpi_input
        
        # Guardar KPI (puede ser None)
        if kpi:
            user_states[user_id]['data']['main_kpi'] = kpi
        
        user_states[user_id]['step'] = 7
        
        kpi_text = kpi if kpi else "Ninguno"
        
        text_response = f"""‚úÖ **KPI guardado:** {kpi_text}

**‚û°Ô∏è PASO 7/8: M√©tricas RICE** üìä
Ahora vamos a calcular el score RICE. Responde las 4 m√©tricas en este formato:

**Formato:** `reach impact confidence effort`

**üìè Definiciones:**
‚Ä¢ **Reach (Alcance):** % de usuarios impactados (0-100)
‚Ä¢ **Impact (Impacto):** Nivel de impacto (1=Bajo, 2=Medio, 3=Alto)  
‚Ä¢ **Confidence (Confianza):** % de confianza en estimaci√≥n (0-100)
‚Ä¢ **Effort (Esfuerzo):** Sprints de desarrollo (ej: 1.5)

**üí° Ejemplo:** `85 3 90 2` 
*85% reach, impacto alto, 90% confianza, 2 sprints*

Escribe los 4 n√∫meros separados por espacios:"""
        
        send_telegram_message(chat_id, text_response, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Step 6 error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en paso 6: {str(e)}")

def handle_step_7_rice(chat_id, user_id, text):
    """PASO 7: M√©tricas RICE"""
    try:
        # Parsear entrada
        parts = text.strip().split()
        
        if len(parts) != 4:
            send_telegram_message(chat_id, f"""‚ùå **Formato incorrecto.** Necesito exactamente 4 n√∫meros.

**Recibido:** {len(parts)} valores
**Esperado:** reach impact confidence effort

**Ejemplo:** `85 3 90 2`

Intenta nuevamente:""", parse_mode='Markdown')
            return
        
        try:
            # Convertir valores
            reach_pct = float(parts[0])
            impact = int(parts[1])  
            confidence_pct = float(parts[2])
            effort = float(parts[3])
            
            # Validar rangos
            validations = []
            
            if not (0 <= reach_pct <= 100):
                validations.append("‚Ä¢ Reach debe estar entre 0-100")
            
            if impact not in [1, 2, 3]:
                validations.append("‚Ä¢ Impact debe ser 1, 2 o 3")
                
            if not (0 <= confidence_pct <= 100):
                validations.append("‚Ä¢ Confidence debe estar entre 0-100")
                
            if effort <= 0:
                validations.append("‚Ä¢ Effort debe ser mayor que 0")
            
            if validations:
                error_text = "‚ùå **Errores de validaci√≥n:**\n" + "\n".join(validations)
                error_text += "\n\n**Formato:** `reach impact confidence effort`\n**Ejemplo:** `85 3 90 2`"
                send_telegram_message(chat_id, error_text, parse_mode='Markdown')
                return
            
            # Convertir a formato interno
            reach = reach_pct / 100.0  # 0.0-1.0
            confidence = confidence_pct / 100.0  # 0.0-1.0
            
            # Calcular score
            score = (reach * impact * confidence) / effort
            
            # Guardar m√©tricas
            user_states[user_id]['data'].update({
                'reach': reach,
                'impact': impact,
                'confidence': confidence,
                'effort': effort
            })
            
            user_states[user_id]['step'] = 8
            
            # Determinar prioridad
            if score >= 2.0:
                priority = "üî• **ALTA PRIORIDAD** - Ejecutar inmediatamente"
                priority_class = "alta"
            elif score >= 1.0:
                priority = "‚≠ê **MEDIA PRIORIDAD** - Pr√≥ximos sprints"
                priority_class = "media"
            else:
                priority = "üìã **BAJA PRIORIDAD** - Re-evaluar necesidad"
                priority_class = "baja"
            
            # Resumen completo
            data = user_states[user_id]['data']
            
            text_response = f"""‚úÖ **M√©tricas RICE calculadas:**

üìä **Score RICE: {score:.3f}** - {priority}

**üìã RESUMEN COMPLETO:**
‚Ä¢ **Nombre:** {data['initiative_name']}
‚Ä¢ **Responsable:** {data['owner']}
‚Ä¢ **Equipo:** {data['team']}
‚Ä¢ **Portal:** {data['portal']}
‚Ä¢ **KPI:** {data.get('main_kpi', 'Ninguno')}

**üìè M√©tricas:**
‚Ä¢ **Alcance:** {reach_pct}% de usuarios
‚Ä¢ **Impacto:** {impact}/3 ({"Bajo" if impact == 1 else "Medio" if impact == 2 else "Alto"})
‚Ä¢ **Confianza:** {confidence_pct}% 
‚Ä¢ **Esfuerzo:** {effort} sprints

**üìä Score = ({reach_pct}% √ó {impact} √ó {confidence_pct}%) √∑ {effort} = {score:.3f}**

**‚û°Ô∏è PASO 8/8: Confirmaci√≥n**
¬øTodo est√° correcto? Escribe:
‚Ä¢ **"confirmar"** - Crear la iniciativa
‚Ä¢ **"cancelar"** - Cancelar proceso
‚Ä¢ **"editar"** - Corregir datos"""
            
            send_telegram_message(chat_id, text_response, parse_mode='Markdown')
            
        except ValueError as e:
            send_telegram_message(chat_id, f"""‚ùå **Error de formato.** Todos deben ser n√∫meros v√°lidos.

**Error:** {str(e)}

**Formato correcto:** `reach impact confidence effort`
**Ejemplo:** `85 3 90 2`

Intenta nuevamente:""", parse_mode='Markdown')
            return
        
    except Exception as e:
        logger.error(f"‚ùå Step 7 error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error en paso 7: {str(e)}")

def handle_step_8_confirmation(chat_id, user_id, text):
    """PASO 8: Confirmaci√≥n final"""
    try:
        command = text.strip().lower()
        
        if command in ['confirmar', 'confirm', 's√≠', 'si', 'yes', 'ok']:
            # Crear la iniciativa
            data = user_states[user_id]['data']
            
            send_telegram_message(chat_id, "‚ö° **Creando iniciativa...** Esto puede tardar unos segundos.")
            
            # Llamar a la funci√≥n de creaci√≥n
            result = create_initiative(data)
            
            if result.get('success'):
                # Calcular score para mostrar
                score = calculate_score_fast(data)
                priority_emoji = get_priority_emoji_safe(score)
                
                success_text = f"""‚úÖ **¬°INICIATIVA CREADA EXITOSAMENTE!** üéâ

{priority_emoji} **{data['initiative_name']}**
üìä **Score RICE:** {score:.3f}

**Datos guardados:**
üë§ **Responsable:** {data['owner']}
üë• **Equipo:** {data['team']}  
üñ•Ô∏è **Portal:** {data['portal']}
üìà **KPI:** {data.get('main_kpi', 'Ninguno')}

**M√©tricas RICE:**
‚Ä¢ Alcance: {data['reach']*100:.0f}%
‚Ä¢ Impacto: {data['impact']}/3
‚Ä¢ Confianza: {data['confidence']*100:.0f}%
‚Ä¢ Esfuerzo: {data['effort']} sprints

**üöÄ Pr√≥ximos pasos:**
‚Ä¢ Aparecer√° en lista principal: `iniciativas`
‚Ä¢ Incluida en an√°lisis AI: `analizar`
‚Ä¢ Buscar por equipo: `buscar {data['team']}`"""
                
                send_telegram_message(chat_id, success_text, parse_mode='Markdown')
                
                # Limpiar estado
                del user_states[user_id]
                
            else:
                error_msg = result.get('error', 'Error desconocido')
                validation_errors = result.get('validation_errors', [])
                
                error_text = f"‚ùå **Error creando iniciativa:** {error_msg}"
                
                if validation_errors:
                    error_text += "\n\n**Errores de validaci√≥n:**"
                    for error in validation_errors:
                        error_text += f"\n‚Ä¢ {error}"
                
                error_text += "\n\n**üîÑ El proceso sigue activo.** Puedes:"
                error_text += "\n‚Ä¢ **'editar'** - Corregir datos"
                error_text += "\n‚Ä¢ **'cancelar'** - Cancelar proceso"
                error_text += "\n‚Ä¢ **'confirmar'** - Reintentar creaci√≥n"
                
                send_telegram_message(chat_id, error_text, parse_mode='Markdown')
                
        elif command in ['cancelar', 'cancel', 'no']:
            # Cancelar proceso
            del user_states[user_id]
            send_telegram_message(chat_id, """‚ùå **Proceso cancelado.**

üíæ **Datos no guardados.** La iniciativa no fue creada.

üí° **Para crear otra iniciativa:** `crear`""", parse_mode='Markdown')
            
        elif command in ['editar', 'edit', 'corregir']:
            # Opci√≥n de edici√≥n (simplificada - volver al inicio)
            del user_states[user_id]
            send_telegram_message(chat_id, """üìù **Edici√≥n solicitada.**

üîÑ **Proceso reiniciado.** Tendr√°s que ingresar todos los datos nuevamente.

üí° **Para comenzar:** `crear`""", parse_mode='Markdown')
            
        else:
            # Comando no reconocido
            send_telegram_message(chat_id, f"""‚ùì **Comando no reconocido:** "{command}"

**Opciones disponibles:**
‚Ä¢ **"confirmar"** - Crear la iniciativa  
‚Ä¢ **"cancelar"** - Cancelar proceso
‚Ä¢ **"editar"** - Reiniciar proceso

Escribe una de las opciones:""", parse_mode='Markdown')
            
    except Exception as e:
        logger.error(f"‚ùå Step 8 error: {e}")
        if user_id in user_states:
            del user_states[user_id]
        send_telegram_message(chat_id, f"‚ùå Error en confirmaci√≥n: {str(e)}\n\nProceso cancelado. Usa `crear` para intentar nuevamente.")

# ===== FUNCIONES AUXILIARES ADICIONALES =====

def get_priority_emoji_safe(score):
    """Obtener emoji de prioridad de forma segura"""
    try:
        score_val = float(score) if score else 0
        if score_val >= 2.0:
            return "üî•"  # Alta prioridad
        elif score_val >= 1.0:
            return "‚≠ê"  # Media prioridad
        else:
            return "üìã"  # Baja prioridad
    except:
        return "üìã"

def handle_filter_by_status(chat_id, status):
    """Filtrar iniciativas por estado"""
    try:
        send_telegram_message(chat_id, f"‚è≥ **Filtrando por estado:** {status}")
        
        from database import get_initiatives_by_status
        data = get_initiatives_by_status([status.title()])
        
        if not data.get("success"):
            send_telegram_message(chat_id, f"‚ùå Error: {data.get('error')}")
            return
        
        initiatives = data.get("data", [])
        
        if not initiatives:
            send_telegram_message(chat_id, f"üì≠ **No hay iniciativas con estado:** {status}")
            return
        
        text = f"üìä **INICIATIVAS - {status.upper()}** ({len(initiatives)} encontradas)\n\n"
        
        for i, init in enumerate(initiatives[:10], 1):
            try:
                formatted = format_initiative_summary_safe(init, i)
                text += f"{formatted}\n\n"
            except Exception as e:
                logger.warning(f"Error formatting initiative {i}: {e}")
                continue
        
        if len(initiatives) > 10:
            text += f"üìå **{len(initiatives) - 10} iniciativas m√°s...** Usa `buscar` para filtrar."
        
        send_telegram_message(chat_id, text, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"‚ùå Filter by status error: {e}")
        send_telegram_message(chat_id, f"‚ùå Error filtrando: {str(e)}")

def handle_status_info(chat_id):
    """Mostrar informaci√≥n de estados disponibles"""
    text = """üìã **ESTADOS DE INICIATIVAS** - Flujo Real

**üîÑ Estados Disponibles:**
‚Ä¢ ‚è≥ `Pending` - Pendiente de revisi√≥n  
‚Ä¢ üëÅÔ∏è `Reviewed` - Revisada
‚Ä¢ ‚≠ê `Prioritized` - Priorizada
‚Ä¢ üìÇ `Backlog` - En backlog
‚Ä¢ üîß `Sprint` - En desarrollo
‚Ä¢ üöÄ `Production` - En producci√≥n
‚Ä¢ üìä `Monitoring` - En monitoreo
‚Ä¢ ‚ùå `Discarded` - Descartada

**üì± Comandos de Filtro:**
‚Ä¢ `pending` - Ver pendientes
‚Ä¢ `sprint` - Ver en desarrollo
‚Ä¢ `production` - Ver implementadas
‚Ä¢ `monitoring` - Ver monitoreadas

**‚û°Ô∏è Flujo T√≠pico:**
Pending ‚Üí Reviewed ‚Üí Prioritized ‚Üí Backlog ‚Üí Sprint ‚Üí Production ‚Üí Monitoring

üí° **Tip:** Usa `iniciativas` para ver todas ordenadas por score RICE."""
    
    send_telegram_message(chat_id, text, parse_mode='Markdown')
